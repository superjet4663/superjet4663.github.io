<section id="module-xgrammar">
  <span id="xgrammar"></span><span id="apixgrammar"></span>
  <h1>
    xgrammar<a class="headerlink" href="#module-xgrammar" title="Permalink to this heading">¶</a>
  </h1>
  <p><strong>Classes:</strong></p>
  <div class="wy-table-responsive">
    <table class="autosummary longtable docutils align-default">
      <tbody>
        <tr class="row-odd">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.CompiledGrammar"
                title="xgrammar.CompiledGrammar"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">CompiledGrammar</span></code
                ></a
              >()
            </p>
          </td>
          <td><p>This is the primary object to store compiled grammar.</p></td>
        </tr>
        <tr class="row-even">
          <td>
            <p>
              <a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.Grammar"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">Grammar</span></code
                ></a
              >()
            </p>
          </td>
          <td>
            <p>
              This class represents a grammar object in XGrammar, and can be used later in the
              grammar-guided generation.
            </p>
          </td>
        </tr>
        <tr class="row-odd">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.GrammarCompiler"
                title="xgrammar.GrammarCompiler"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">GrammarCompiler</span></code
                ></a
              >(tokenizer_info,&nbsp;*[,&nbsp;...])
            </p>
          </td>
          <td><p>The compiler for grammars.</p></td>
        </tr>
        <tr class="row-even">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.GrammarMatcher"
                title="xgrammar.GrammarMatcher"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">GrammarMatcher</span></code
                ></a
              >(compiled_grammar,&nbsp;*[,&nbsp;...])
            </p>
          </td>
          <td>
            <p>
              Match the output of the LLM to the specified grammar, then generate the mask for the
              next token.
            </p>
          </td>
        </tr>
        <tr class="row-odd">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.TokenizerInfo"
                title="xgrammar.TokenizerInfo"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">TokenizerInfo</span></code
                ></a
              >(encoded_vocab[,&nbsp;vocab_type,&nbsp;...])
            </p>
          </td>
          <td>
            <p>
              The tokenizer info contains the vocabulary, the type of the vocabulary, and necessary
              information for the grammar-guided generation.
            </p>
          </td>
        </tr>
        <tr class="row-even">
          <td>
            <p>
              <a class="reference internal" href="#xgrammar.VocabType" title="xgrammar.VocabType"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">VocabType</span></code
                ></a
              >(value[,&nbsp;names,&nbsp;module,&nbsp;qualname,&nbsp;...])
            </p>
          </td>
          <td><p>The type of the vocabulary.</p></td>
        </tr>
      </tbody>
    </table>
  </div>
  <p><strong>Functions:</strong></p>
  <div class="wy-table-responsive">
    <table class="autosummary longtable docutils align-default">
      <tbody>
        <tr class="row-odd">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.allocate_token_bitmask"
                title="xgrammar.allocate_token_bitmask"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">allocate_token_bitmask</span></code
                ></a
              >(batch_size,&nbsp;vocab_size)
            </p>
          </td>
          <td><p>Allocate the bitmask for the next token prediction.</p></td>
        </tr>
        <tr class="row-even">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.apply_token_bitmask_inplace"
                title="xgrammar.apply_token_bitmask_inplace"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">apply_token_bitmask_inplace</span></code
                ></a
              >(logits,&nbsp;bitmask,&nbsp;*)
            </p>
          </td>
          <td><p>Apply the bitmask to the logits in-place.</p></td>
        </tr>
        <tr class="row-odd">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.get_bitmask_shape"
                title="xgrammar.get_bitmask_shape"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">get_bitmask_shape</span></code
                ></a
              >(batch_size,&nbsp;vocab_size)
            </p>
          </td>
          <td><p>Return the shape of the bitmask: (batch_size, ceil(vocab_size / 32))</p></td>
        </tr>
        <tr class="row-even">
          <td>
            <p>
              <a
                class="reference internal"
                href="#xgrammar.reset_token_bitmask"
                title="xgrammar.reset_token_bitmask"
                ><code class="xref py py-obj docutils literal notranslate"
                  ><span class="pre">reset_token_bitmask</span></code
                ></a
              >(bitmask)
            </p>
          </td>
          <td><p>Reset the bitmask to the full mask.</p></td>
        </tr>
      </tbody>
    </table>
  </div>
  <dl class="py class">
    <dt class="sig sig-object py" id="xgrammar.CompiledGrammar">
      <em class="property"><span class="pre">class</span><span class="w"> </span></em
      ><span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">CompiledGrammar</span></span
      ><a class="headerlink" href="#xgrammar.CompiledGrammar" title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd>
      <p>This is the primary object to store compiled grammar.</p>
      <p>
        A CompiledGrammar can be used to construct GrammarMatcher to generate token masks
        efficiently.
      </p>
      <div class="admonition note">
        <p class="admonition-title">Note</p>
        <p>
          Do not construct this class directly, instead use
          <a
            class="reference internal"
            href="#xgrammar.GrammarCompiler"
            title="xgrammar.GrammarCompiler"
            ><code class="xref py py-class docutils literal notranslate"
              ><span class="pre">GrammarCompiler</span></code
            ></a
          >
          to construct the object.
        </p>
      </div>
      <p><strong>Attributes:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.CompiledGrammar.grammar"
                    title="xgrammar.CompiledGrammar.grammar"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">grammar</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The original grammar.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.CompiledGrammar.tokenizer_info"
                    title="xgrammar.CompiledGrammar.tokenizer_info"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">tokenizer_info</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The tokenizer info associated with the compiled grammar.</p></td>
            </tr>
          </tbody>
        </table>
      </div>
      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.CompiledGrammar.grammar">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">grammar</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.grammar.Grammar"
              ><span class="pre">Grammar</span></a
            ></em
          ><a
            class="headerlink"
            href="#xgrammar.CompiledGrammar.grammar"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>The original grammar.</p></dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.CompiledGrammar.tokenizer_info">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">tokenizer_info</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><a
              class="reference internal"
              href="#xgrammar.TokenizerInfo"
              title="xgrammar.tokenizer_info.TokenizerInfo"
              ><span class="pre">TokenizerInfo</span></a
            ></em
          ><a
            class="headerlink"
            href="#xgrammar.CompiledGrammar.tokenizer_info"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>The tokenizer info associated with the compiled grammar.</p></dd>
      </dl>
    </dd>
  </dl>

  <dl class="py class">
    <dt class="sig sig-object py" id="xgrammar.Grammar">
      <em class="property"><span class="pre">class</span><span class="w"> </span></em
      ><span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">Grammar</span></span
      ><a class="headerlink" href="#xgrammar.Grammar" title="Permalink to this definition">¶</a>
    </dt>
    <dd>
      <p>
        This class represents a grammar object in XGrammar, and can be used later in the
        grammar-guided generation.
      </p>
      <p>
        The Grammar object supports context-free grammar (CFG). EBNF (extended Backus-Naur Form) is
        used as the format of the grammar. There are many specifications for EBNF in the literature,
        and we follow the specification of GBNF (GGML BNF) in
        <a
          class="reference external"
          href="https://github.com/ggerganov/llama.cpp/blob/master/grammars/README.md"
          >https://github.com/ggerganov/llama.cpp/blob/master/grammars/README.md</a
        >.
      </p>
      <p>When printed, the grammar will be converted to GBNF format.</p>
      <p><strong>Methods:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.Grammar.builtin_json_grammar"
                    title="xgrammar.Grammar.builtin_json_grammar"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">builtin_json_grammar</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Get the grammar of standard JSON.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.Grammar.concat"
                    title="xgrammar.Grammar.concat"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">concat</span></code
                    ></a
                  >(*grammars)
                </p>
              </td>
              <td>
                <p>Create a grammar that matches the concatenation of the grammars in the list.</p>
              </td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.Grammar.from_ebnf"
                    title="xgrammar.Grammar.from_ebnf"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">from_ebnf</span></code
                    ></a
                  >(ebnf_string,&nbsp;*[,&nbsp;root_rule_name])
                </p>
              </td>
              <td><p>Construct a grammar from EBNF string.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.Grammar.from_json_schema"
                    title="xgrammar.Grammar.from_json_schema"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">from_json_schema</span></code
                    ></a
                  >(schema,&nbsp;*[,&nbsp;...])
                </p>
              </td>
              <td><p>Construct a grammar from JSON schema.</p></td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.Grammar.from_regex"
                    title="xgrammar.Grammar.from_regex"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">from_regex</span></code
                    ></a
                  >(regex_string)
                </p>
              </td>
              <td><p>Create a grammar from a regular expression string.</p></td>
            </tr>
          </tbody>
        </table>
      </div>
      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.Grammar.builtin_json_grammar">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">builtin_json_grammar</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.Grammar"
                title="xgrammar.grammar.Grammar"
                ><span class="pre">Grammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.Grammar.builtin_json_grammar"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Get the grammar of standard JSON. This is compatible with the official JSON grammar
            specification in
            <a class="reference external" href="https://www.json.org/json-en.html"
              >https://www.json.org/json-en.html</a
            >.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Returns<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p><strong>grammar</strong> – The JSON grammar.</p>
            </dd>
            <dt class="field-even">Return type<span class="colon">:</span></dt>
            <dd class="field-even">
              <p>
                <a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.Grammar"
                  >Grammar</a
                >
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.Grammar.concat">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">concat</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="o"><span class="pre">*</span></span
            ><span class="n"><span class="pre">grammars</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><a
                class="reference internal"
                href="#xgrammar.Grammar"
                title="xgrammar.grammar.Grammar"
                ><span class="pre">Grammar</span></a
              ></span
            ></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.Grammar"
                title="xgrammar.grammar.Grammar"
                ><span class="pre">Grammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.Grammar.concat"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Create a grammar that matches the concatenation of the grammars in the list. That is
            equivalent to using the <cite>+</cite> operator to concatenate the grammars in the list.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <strong>grammars</strong> (<em>List</em><em>[</em
                ><a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.Grammar"
                  ><em>Grammar</em></a
                ><em>]</em>) – The grammars to create the concatenation of.
              </p>
            </dd>
            <dt class="field-even">Returns<span class="colon">:</span></dt>
            <dd class="field-even">
              <p><strong>grammar</strong> – The concatenation of the grammars.</p>
            </dd>
            <dt class="field-odd">Return type<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.Grammar"
                  >Grammar</a
                >
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.Grammar.from_ebnf">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">from_ebnf</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">ebnf_string</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">str</span></span></em
          >,
          <em class="sig-param"
            ><span class="o"><span class="pre">*</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">root_rule_name</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">str</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">'root'</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.Grammar"
                title="xgrammar.grammar.Grammar"
                ><span class="pre">Grammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.Grammar.from_ebnf"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Construct a grammar from EBNF string. The EBNF string should follow the format in
            <a
              class="reference external"
              href="https://github.com/ggerganov/llama.cpp/blob/master/grammars/README.md"
              >https://github.com/ggerganov/llama.cpp/blob/master/grammars/README.md</a
            >.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p>
                    <strong>ebnf_string</strong> (<em>str</em>) – The grammar string in EBNF format.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>root_rule_name</strong> (<em>str</em><em>, </em
                    ><em>default: "root"</em>) – The name of the root rule in the grammar.
                  </p>
                </li>
              </ul>
            </dd>
            <dt class="field-even">Raises<span class="colon">:</span></dt>
            <dd class="field-even">
              <p>
                <strong>RuntimeError</strong> – When converting the regex pattern fails, with
                details about the parsing error.
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.Grammar.from_json_schema">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">from_json_schema</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">schema</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">str</span><span class="p"><span class="pre">,</span></span
              ><span class="w"> </span><span class="pre">Type</span
              ><span class="p"><span class="pre">[</span></span
              ><span class="pre">BaseModel</span><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">]</span></span></span
            ></em
          >,
          <em class="sig-param"
            ><span class="o"><span class="pre">*</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">any_whitespace</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">True</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">indent</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">None</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">separators</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">str</span><span class="p"><span class="pre">,</span></span
              ><span class="w"> </span><span class="pre">str</span
              ><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">]</span></span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">None</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">strict_mode</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">True</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.Grammar"
                title="xgrammar.grammar.Grammar"
                ><span class="pre">Grammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.Grammar.from_json_schema"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Construct a grammar from JSON schema. Pydantic model or JSON schema string can be used
            to specify the schema.
          </p>
          <p>
            It allows any whitespace by default. If user want to specify the format of the JSON, set
            <cite>any_whitespace</cite> to False and use the <cite>indent</cite> and
            <cite>separators</cite> parameters. The meaning and the default values of the parameters
            follows the convention in json.dumps().
          </p>
          <p>It internally converts the JSON schema to a EBNF grammar.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p>
                    <strong>schema</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em
                    ><em>Type</em><em>[</em><em>BaseModel</em><em>]</em><em>]</em>) – The schema
                    string or Pydantic model.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>any_whitespace</strong> (<em>bool</em><em>, </em><em>default: True</em>)
                    – Whether to use any whitespace. If True, the generated grammar will ignore the
                    indent and separators parameters, and allow any whitespace.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>indent</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em
                    ><em>, </em><em>default: None</em>) –
                  </p>
                  <p>
                    The number of spaces for indentation. If None, the output will be in one line.
                  </p>
                  <p>
                    Note that specifying the indentation means forcing the LLM to generate JSON
                    strings strictly formatted. However, some models may tend to generate JSON
                    strings that are not strictly formatted. In this case, forcing the LLM to
                    generate strictly formatted JSON strings may degrade the generation quality. See
                    &lt;<a
                      class="reference external"
                      href="https://github.com/sgl-project/sglang/issues/2216#issuecomment-2516192009"
                      >https://github.com/sgl-project/sglang/issues/2216#issuecomment-2516192009</a
                    >&gt; for more details.
                  </p>
                  <p></p>
                </li>
                <li>
                  <p>
                    <strong>separators</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em
                    ><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>, </em
                    ><em>default: None</em>) – Two separators used in the schema: comma and colon.
                    Examples: (“,”, “:”), (”, “, “: “). If None, the default separators will be
                    used: (“,”, “: “) when the indent is not None, and (”, “, “: “) otherwise.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>strict_mode</strong> (<em>bool</em><em>, </em><em>default: True</em>) –
                  </p>
                  <p>
                    Whether to use strict mode. In strict mode, the generated grammar will not allow
                    properties and items that is not specified in the schema. This is equivalent to
                    setting unevaluatedProperties and unevaluatedItems to false. It also disallows
                    empty JSON objects and arrays.
                  </p>
                  <p>
                    This helps LLM to generate accurate output in the grammar-guided generation with
                    JSON schema.
                  </p>
                  <p></p>
                </li>
              </ul>
            </dd>
            <dt class="field-even">Returns<span class="colon">:</span></dt>
            <dd class="field-even">
              <p><strong>grammar</strong> – The constructed grammar.</p>
            </dd>
            <dt class="field-odd">Return type<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.Grammar"
                  >Grammar</a
                >
              </p>
            </dd>
            <dt class="field-even">Raises<span class="colon">:</span></dt>
            <dd class="field-even">
              <p>
                <strong>RuntimeError</strong> – When converting the json schema fails, with details
                about the parsing error.
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.Grammar.from_regex">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">from_regex</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">regex_string</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">str</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.Grammar"
                title="xgrammar.grammar.Grammar"
                ><span class="pre">Grammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.Grammar.from_regex"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>Create a grammar from a regular expression string.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <strong>regex_string</strong> (<em>str</em>) – The regular expression pattern to
                create the grammar from.
              </p>
            </dd>
            <dt class="field-even">Returns<span class="colon">:</span></dt>
            <dd class="field-even">
              <p><strong>grammar</strong> – The constructed grammar from the regex pattern.</p>
            </dd>
            <dt class="field-odd">Return type<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <a class="reference internal" href="#xgrammar.Grammar" title="xgrammar.Grammar"
                  >Grammar</a
                >
              </p>
            </dd>
            <dt class="field-even">Raises<span class="colon">:</span></dt>
            <dd class="field-even">
              <p>
                <strong>RuntimeError</strong> – When parsing the regex pattern fails, with details
                about the parsing error.
              </p>
            </dd>
          </dl>
        </dd>
      </dl>
    </dd>
  </dl>

  <dl class="py class">
    <dt class="sig sig-object py" id="xgrammar.GrammarCompiler">
      <em class="property"><span class="pre">class</span><span class="w"> </span></em
      ><span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">GrammarCompiler</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">tokenizer_info</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><a
            class="reference internal"
            href="#xgrammar.TokenizerInfo"
            title="xgrammar.tokenizer_info.TokenizerInfo"
            ><span class="pre">TokenizerInfo</span></a
          ></span
        ></em
      >,
      <em class="sig-param"
        ><span class="o"><span class="pre">*</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">max_threads</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">int</span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span><span class="default_value"><span class="pre">8</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">cache_enabled</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">True</span></span></em
      ><span class="sig-paren">)</span
      ><a class="headerlink" href="#xgrammar.GrammarCompiler" title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd>
      <p>
        The compiler for grammars. It is associated with a certain tokenizer info, and compiles
        grammars into CompiledGrammar with the tokenizer info. It allows parallel compilation with
        multiple threads, and has a cache to store the compilation result, avoiding compiling the
        same grammar multiple times.
      </p>
      <dl class="field-list simple">
        <dt class="field-odd">Parameters<span class="colon">:</span></dt>
        <dd class="field-odd">
          <ul class="simple">
            <li>
              <p>
                <strong>tokenizer_info</strong> (<a
                  class="reference internal"
                  href="#xgrammar.TokenizerInfo"
                  title="xgrammar.TokenizerInfo"
                  ><em>TokenizerInfo</em></a
                >) – The tokenizer info.
              </p>
            </li>
            <li>
              <p>
                <strong>max_threads</strong> (<em>int</em><em>, </em><em>default: 8</em>) – The
                maximum number of threads used to compile the grammar.
              </p>
            </li>
            <li>
              <p>
                <strong>cache_enabled</strong> (<em>bool</em><em>, </em><em>default: True</em>) –
                Whether to enable the cache.
              </p>
            </li>
          </ul>
        </dd>
      </dl>
      <p><strong>Methods:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarCompiler.clear_cache"
                    title="xgrammar.GrammarCompiler.clear_cache"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">clear_cache</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Clear all cached compiled grammars.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarCompiler.compile_builtin_json_grammar"
                    title="xgrammar.GrammarCompiler.compile_builtin_json_grammar"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">compile_builtin_json_grammar</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Get CompiledGrammar from the standard JSON.</p></td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarCompiler.compile_json_schema"
                    title="xgrammar.GrammarCompiler.compile_json_schema"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">compile_json_schema</span></code
                    ></a
                  >(schema,&nbsp;*[,&nbsp;...])
                </p>
              </td>
              <td><p>Get CompiledGrammar from the specified JSON schema and format.</p></td>
            </tr>
          </tbody>
        </table>
      </div>
      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarCompiler.clear_cache">
          <span class="sig-name descname"><span class="pre">clear_cache</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">None</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarCompiler.clear_cache"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>Clear all cached compiled grammars.</p></dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarCompiler.compile_builtin_json_grammar">
          <span class="sig-name descname"
            ><span class="pre">compile_builtin_json_grammar</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.CompiledGrammar"
                title="xgrammar.compiler.CompiledGrammar"
                ><span class="pre">CompiledGrammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarCompiler.compile_builtin_json_grammar"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>Get CompiledGrammar from the standard JSON.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Returns<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p><strong>compiled_grammar</strong> – The compiled grammar.</p>
            </dd>
            <dt class="field-even">Return type<span class="colon">:</span></dt>
            <dd class="field-even">
              <p>
                <a
                  class="reference internal"
                  href="#xgrammar.CompiledGrammar"
                  title="xgrammar.CompiledGrammar"
                  >CompiledGrammar</a
                >
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarCompiler.compile_json_schema">
          <span class="sig-name descname"><span class="pre">compile_json_schema</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">schema</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">str</span><span class="p"><span class="pre">,</span></span
              ><span class="w"> </span><span class="pre">Type</span
              ><span class="p"><span class="pre">[</span></span
              ><span class="pre">BaseModel</span><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">]</span></span></span
            ></em
          >,
          <em class="sig-param"
            ><span class="o"><span class="pre">*</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">any_whitespace</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">True</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">indent</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">None</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">separators</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">str</span><span class="p"><span class="pre">,</span></span
              ><span class="w"> </span><span class="pre">str</span
              ><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">]</span></span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">None</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">strict_mode</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">True</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.CompiledGrammar"
                title="xgrammar.compiler.CompiledGrammar"
                ><span class="pre">CompiledGrammar</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarCompiler.compile_json_schema"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Get CompiledGrammar from the specified JSON schema and format. The indent and separators
            parameters follow the same convention as in json.dumps().
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p>
                    <strong>schema</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em
                    ><em>Type</em><em>[</em><em>BaseModel</em><em>]</em><em>]</em>) – The schema
                    string or Pydantic model.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>indent</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em
                    ><em>, </em><em>default: None</em>) – The number of spaces for indentation. If
                    None, the output will be in one line.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>separators</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em
                    ><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>, </em
                    ><em>default: None</em>) – Two separators used in the schema: comma and colon.
                    Examples: (“,”, “:”), (”, “, “: “). If None, the default separators will be
                    used: (“,”, “: “) when the indent is not None, and (”, “, “: “) otherwise.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>strict_mode</strong> (<em>bool</em><em>, </em><em>default: True</em>) –
                    Whether to use strict mode. In strict mode, the generated grammar will not allow
                    properties and items that is not specified in the schema. This is equivalent to
                    setting unevaluatedProperties and unevaluatedItems to false.
                  </p>
                </li>
              </ul>
            </dd>
            <dt class="field-even">Returns<span class="colon">:</span></dt>
            <dd class="field-even">
              <p><strong>compiled_grammar</strong> – The compiled grammar.</p>
            </dd>
            <dt class="field-odd">Return type<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <a
                  class="reference internal"
                  href="#xgrammar.CompiledGrammar"
                  title="xgrammar.CompiledGrammar"
                  >CompiledGrammar</a
                >
              </p>
            </dd>
          </dl>
        </dd>
      </dl>
    </dd>
  </dl>

  <dl class="py class">
    <dt class="sig sig-object py" id="xgrammar.GrammarMatcher">
      <em class="property"><span class="pre">class</span><span class="w"> </span></em
      ><span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">GrammarMatcher</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">compiled_grammar</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><a
            class="reference internal"
            href="#xgrammar.CompiledGrammar"
            title="xgrammar.compiler.CompiledGrammar"
            ><span class="pre">CompiledGrammar</span></a
          ></span
        ></em
      >,
      <em class="sig-param"
        ><span class="o"><span class="pre">*</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">override_stop_tokens</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">List</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">int</span><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">,</span></span
          ><span class="w"> </span><span class="pre">int</span
          ><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">]</span></span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">None</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">terminate_without_stop_token</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">False</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">max_rollback_tokens</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">int</span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em
      ><span class="sig-paren">)</span
      ><a class="headerlink" href="#xgrammar.GrammarMatcher" title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd>
      <p>
        Match the output of the LLM to the specified grammar, then generate the mask for the next
        token. This is the core class in the grammar-guided generation.
      </p>
      <p>
        This class maintains a stateful matcher that can accept tokens and strings, then match them
        to the specified grammar. The matcher can provide a bitmask for the next token prediction,
        so that the output of the LLM follows the specified grammar. Its state can be reset and
        rolled back by tokens. It also provides utilities for jump-forward decoding.
      </p>
      <p>
        After matching the whole grammar, the matcher will accept a stop token. The token mask at
        this time will only allow stop tokens. After accepting the stop token, the matcher will
        terminate, then it cannot accept any new token or generate a new token mask, meaning the
        generation is finished.
      </p>
      <p>
        Under the hood, it utilizes a pushdown automaton with backtracking to match the grammar,
        with optimizations specific to LLM token mask generation.
      </p>
      <dl class="field-list simple">
        <dt class="field-odd">Parameters<span class="colon">:</span></dt>
        <dd class="field-odd">
          <ul class="simple">
            <li>
              <p>
                <strong>compiled_grammar</strong> (<a
                  class="reference internal"
                  href="#xgrammar.CompiledGrammar"
                  title="xgrammar.CompiledGrammar"
                  ><em>CompiledGrammar</em></a
                >) – The initialization context for the grammar matcher.
              </p>
            </li>
            <li>
              <p>
                <strong>override_stop_tokens</strong> (<em>Optional</em><em>[</em><em>Union</em
                ><em>[</em><em>int</em><em>, </em><em>List</em><em>[</em><em>int</em><em>]</em
                ><em>]</em><em>]</em><em>, </em><em>default: None</em>) – If not None, the stop
                tokens to override the ones in the grammar.
              </p>
            </li>
            <li>
              <p>
                <strong>terminate_without_stop_token</strong> (<em>bool</em><em>, </em
                ><em>default: False</em>) – Whether to terminate the matcher without accepting a
                stop token.
              </p>
            </li>
            <li>
              <p>
                <strong>max_rollback_tokens</strong> (<em>int</em><em>, </em><em>default: 0</em>) –
                The maximum number of rollback tokens allowed. The rollback operation is useful for
                jump-forward decoding and speculative decoding.
              </p>
            </li>
          </ul>
        </dd>
      </dl>
      <p><strong>Methods:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.accept_token"
                    title="xgrammar.GrammarMatcher.accept_token"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">accept_token</span></code
                    ></a
                  >(token_id,&nbsp;*[,&nbsp;debug_print])
                </p>
              </td>
              <td><p>Accept one token and update the state of the matcher.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.fill_next_token_bitmask"
                    title="xgrammar.GrammarMatcher.fill_next_token_bitmask"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">fill_next_token_bitmask</span></code
                    ></a
                  >(bitmask[,&nbsp;index])
                </p>
              </td>
              <td><p>Fill the bitmask for the next token prediction.</p></td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.find_jump_forward_string"
                    title="xgrammar.GrammarMatcher.find_jump_forward_string"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">find_jump_forward_string</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Find the jump-forward string for jump-forward decoding.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.is_terminated"
                    title="xgrammar.GrammarMatcher.is_terminated"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">is_terminated</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Check if the matcher has terminated.</p></td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.reset"
                    title="xgrammar.GrammarMatcher.reset"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">reset</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Reset the matcher to the initial state.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.rollback"
                    title="xgrammar.GrammarMatcher.rollback"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">rollback</span></code
                    ></a
                  >([num_tokens])
                </p>
              </td>
              <td><p>Rollback the matcher to a previous state by several tokens.</p></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p><strong>Attributes:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.max_rollback_tokens"
                    title="xgrammar.GrammarMatcher.max_rollback_tokens"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">max_rollback_tokens</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>Get the maximum number of rollback tokens allowed.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.GrammarMatcher.stop_token_ids"
                    title="xgrammar.GrammarMatcher.stop_token_ids"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">stop_token_ids</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The ids of the stop tokens used in the matcher.</p></td>
            </tr>
          </tbody>
        </table>
      </div>
      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.accept_token">
          <span class="sig-name descname"><span class="pre">accept_token</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">token_id</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">int</span></span></em
          >,
          <em class="sig-param"
            ><span class="o"><span class="pre">*</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">debug_print</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">False</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">bool</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.accept_token"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>Accept one token and update the state of the matcher.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p><strong>token_id</strong> (<em>int</em>) – The id of the token to accept.</p>
                </li>
                <li>
                  <p>
                    <strong>debug_print</strong> (<em>bool</em><em>, </em><em>default: False</em>) –
                    Whether to print information about the internal state of the matcher. Helpful
                    for debugging.
                  </p>
                </li>
              </ul>
            </dd>
            <dt class="field-even">Returns<span class="colon">:</span></dt>
            <dd class="field-even">
              <p><strong>accepted</strong> – Whether the token is accepted.</p>
            </dd>
            <dt class="field-odd">Return type<span class="colon">:</span></dt>
            <dd class="field-odd"><p>bool</p></dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.fill_next_token_bitmask">
          <span class="sig-name descname"><span class="pre">fill_next_token_bitmask</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">bitmask</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">index</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">int</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">0</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">None</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.fill_next_token_bitmask"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Fill the bitmask for the next token prediction. The input bitmask can be generated by
            allocate_token_bitmask, and must be on CPU. bitmask[index] will be filled with the next
            token bitmask.
          </p>
          <p>This method does not change the matcher state.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p>
                    <strong>bitmask</strong> (<em>torch.Tensor</em>) – The bitmask for the next
                    token prediction.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>index</strong> (<em>int</em><em>, </em><em>default: 0</em>) – The batch
                    id of the bitmask.
                  </p>
                </li>
              </ul>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.find_jump_forward_string">
          <span class="sig-name descname"><span class="pre">find_jump_forward_string</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">str</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.find_jump_forward_string"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Find the jump-forward string for jump-forward decoding. This is the longest string that
            certainly conforms with the current grammar from the current matcher state. This string
            can become the output of the LLM without requiring LLM decoding.
          </p>
          <p>This method does not change the matcher state.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Returns<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p><strong>jump_forward_string</strong> – The jump-forward string.</p>
            </dd>
            <dt class="field-even">Return type<span class="colon">:</span></dt>
            <dd class="field-even"><p>str</p></dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.is_terminated">
          <span class="sig-name descname"><span class="pre">is_terminated</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">bool</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.is_terminated"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Check if the matcher has terminated. If terminate_without_stop_token is False, the
            matcher will terminate if it has accepted the stop token. Otherwise, the matcher will
            terminate after matching the whole grammar.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Returns<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p><strong>terminated</strong> – Whether the matcher has terminated.</p>
            </dd>
            <dt class="field-even">Return type<span class="colon">:</span></dt>
            <dd class="field-even"><p>bool</p></dd>
          </dl>
        </dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.max_rollback_tokens">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">max_rollback_tokens</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">int</span></em
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.max_rollback_tokens"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>Get the maximum number of rollback tokens allowed.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Returns<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p><strong>max_rollback_tokens</strong> – The maximum number of rollback tokens.</p>
            </dd>
            <dt class="field-even">Return type<span class="colon">:</span></dt>
            <dd class="field-even"><p>int</p></dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.reset">
          <span class="sig-name descname"><span class="pre">reset</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">None</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.reset"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>Reset the matcher to the initial state.</p></dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.rollback">
          <span class="sig-name descname"><span class="pre">rollback</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">num_tokens</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">int</span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">1</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">None</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.rollback"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>Rollback the matcher to a previous state by several tokens.</p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <strong>num_tokens</strong> (<em>int</em><em>, </em><em>default: 1</em>) – The
                number of tokens to rollback. It cannot exceed the current number of steps, nor can
                it exceed the specified maximum number of rollback tokens.
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.GrammarMatcher.stop_token_ids">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">stop_token_ids</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">List</span
            ><span class="p"><span class="pre">[</span></span
            ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em
          ><a
            class="headerlink"
            href="#xgrammar.GrammarMatcher.stop_token_ids"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            The ids of the stop tokens used in the matcher. If specified, the provided stop tokens
            will be used. Otherwise, the stop tokens will be detected from the vocabulary.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Returns<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p><strong>stop_token_ids</strong> – The ids of the stop tokens.</p>
            </dd>
            <dt class="field-even">Return type<span class="colon">:</span></dt>
            <dd class="field-even"><p>List[int]</p></dd>
          </dl>
        </dd>
      </dl>
    </dd>
  </dl>

  <dl class="py class">
    <dt class="sig sig-object py" id="xgrammar.TokenizerInfo">
      <em class="property"><span class="pre">class</span><span class="w"> </span></em
      ><span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">TokenizerInfo</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">encoded_vocab</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">List</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">,</span></span
          ><span class="w"> </span><span class="pre">List</span
          ><span class="p"><span class="pre">[</span></span
          ><span class="pre">str</span><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">]</span></span></span
        ></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">vocab_type</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><a
            class="reference internal"
            href="#xgrammar.VocabType"
            title="xgrammar.tokenizer_info.VocabType"
            ><span class="pre">VocabType</span></a
          ></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">VocabType.RAW</span></span></em
      >,
      <em class="sig-param"
        ><span class="o"><span class="pre">*</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">vocab_size</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">None</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">stop_token_ids</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">List</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">int</span><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">,</span></span
          ><span class="w"> </span><span class="pre">int</span
          ><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">]</span></span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">None</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">prepend_space_in_tokenization</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">bool</span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">False</span></span></em
      ><span class="sig-paren">)</span
      ><a class="headerlink" href="#xgrammar.TokenizerInfo" title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd>
      <p>
        The tokenizer info contains the vocabulary, the type of the vocabulary, and necessary
        information for the grammar-guided generation.
      </p>
      <p>
        Note that although some tokenizers will encode the tokens in a special format, e.g.
        “&lt;0x1B&gt;” for “” in the ByteFallback tokenizer, and “Ġ” for ” ” in the Byte-Level BPE
        tokenizer, TokenizerInfo always decodes the vocabulary to the original format (e.g. “” and ”
        “).
      </p>
      <p>
        Also note that some models (e.g. Phi-3 and Deepseek-V2) may pad the vocabulary to a multiple
        of 32. In this case, the model’s vocab_size is larger than the tokenizer’s vocabulary size.
        Please pass the model’s vocab_size to the vocab_size parameter in the constructor, because
        this information is used to determine the size of the token mask.
      </p>
      <dl class="field-list simple">
        <dt class="field-odd">Parameters<span class="colon">:</span></dt>
        <dd class="field-odd">
          <ul class="simple">
            <li>
              <p>
                <strong>encoded_vocab</strong> (<em>Union</em><em>[</em><em>List</em><em>[</em
                ><em>bytes</em><em>]</em><em>, </em><em>List</em><em>[</em><em>str</em><em>]</em
                ><em>]</em>) – The encoded vocabulary of the tokenizer.
              </p>
            </li>
            <li>
              <p>
                <strong>vocab_type</strong> (<a
                  class="reference internal"
                  href="#xgrammar.VocabType"
                  title="xgrammar.VocabType"
                  ><em>VocabType</em></a
                ><em>, </em><em>default: VocabType.RAW</em>) – The type of the vocabulary. See also
                VocabType.
              </p>
            </li>
            <li>
              <p>
                <strong>vocab_size</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em
                ><em>, </em><em>default: None</em>) – The size of the vocabulary. If not provided,
                the vocabulary size will be len(encoded_vocab).
              </p>
            </li>
            <li>
              <p>
                <strong>stop_token_ids</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em
                ><em>int</em><em>]</em><em>]</em><em>, </em><em>default: None</em>) – The stop token
                ids. If not provided, the stop token ids will be auto detected (but may not be
                correct).
              </p>
            </li>
            <li>
              <p>
                <strong>prepend_space_in_tokenization</strong> (<em>bool</em><em>, </em
                ><em>default: False</em>) – Whether the tokenizer will prepend a space before the
                text in the tokenization process.
              </p>
            </li>
          </ul>
        </dd>
      </dl>
      <p><strong>Attributes:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.decoded_vocab"
                    title="xgrammar.TokenizerInfo.decoded_vocab"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">decoded_vocab</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The decoded vocabulary of the tokenizer.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.prepend_space_in_tokenization"
                    title="xgrammar.TokenizerInfo.prepend_space_in_tokenization"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">prepend_space_in_tokenization</span></code
                    ></a
                  >
                </p>
              </td>
              <td>
                <p>
                  Whether the tokenizer will prepend a space before the text in the tokenization
                  process.
                </p>
              </td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.special_token_ids"
                    title="xgrammar.TokenizerInfo.special_token_ids"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">special_token_ids</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The special token ids.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.stop_token_ids"
                    title="xgrammar.TokenizerInfo.stop_token_ids"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">stop_token_ids</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The stop token ids.</p></td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.vocab_size"
                    title="xgrammar.TokenizerInfo.vocab_size"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">vocab_size</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The size of the vocabulary.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.vocab_type"
                    title="xgrammar.TokenizerInfo.vocab_type"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">vocab_type</span></code
                    ></a
                  >
                </p>
              </td>
              <td><p>The type of the vocabulary.</p></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p><strong>Methods:</strong></p>
      <div class="wy-table-responsive">
        <table class="autosummary longtable docutils align-default">
          <tbody>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.dump_metadata"
                    title="xgrammar.TokenizerInfo.dump_metadata"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">dump_metadata</span></code
                    ></a
                  >()
                </p>
              </td>
              <td><p>Dump the metadata of the tokenizer to a json string.</p></td>
            </tr>
            <tr class="row-even">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.from_huggingface"
                    title="xgrammar.TokenizerInfo.from_huggingface"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">from_huggingface</span></code
                    ></a
                  >(tokenizer,&nbsp;*[,&nbsp;vocab_size,&nbsp;...])
                </p>
              </td>
              <td><p>Construct the tokenizer info from the huggingface tokenizer.</p></td>
            </tr>
            <tr class="row-odd">
              <td>
                <p>
                  <a
                    class="reference internal"
                    href="#xgrammar.TokenizerInfo.from_vocab_and_metadata"
                    title="xgrammar.TokenizerInfo.from_vocab_and_metadata"
                    ><code class="xref py py-obj docutils literal notranslate"
                      ><span class="pre">from_vocab_and_metadata</span></code
                    ></a
                  >(encoded_vocab,&nbsp;metadata)
                </p>
              </td>
              <td>
                <p>
                  Construct the tokenizer info from the vocabulary and the metadata string in json
                  format.
                </p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.decoded_vocab">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">decoded_vocab</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">List</span
            ><span class="p"><span class="pre">[</span></span
            ><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></em
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.decoded_vocab"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            The decoded vocabulary of the tokenizer. This converts the tokens in the LLM’s
            vocabulary back to the original format of the input text. E.g. for type ByteFallback,
            the token &lt;0x1B&gt; is converted back to “”.
          </p>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.dump_metadata">
          <span class="sig-name descname"><span class="pre">dump_metadata</span></span
          ><span class="sig-paren">(</span><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"><span class="pre">str</span></span></span
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.dump_metadata"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Dump the metadata of the tokenizer to a json string. It can be used to construct the
            tokenizer info from the vocabulary and the metadata string.
          </p>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.from_huggingface">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">from_huggingface</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">tokenizer</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"><span class="pre">PreTrainedTokenizerBase</span></span></em
          >,
          <em class="sig-param"
            ><span class="o"><span class="pre">*</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">vocab_size</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">None</span></span></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">stop_token_ids</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">List</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">int</span><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">,</span></span
              ><span class="w"> </span><span class="pre">int</span
              ><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">]</span></span></span
            ><span class="w"> </span><span class="o"><span class="pre">=</span></span
            ><span class="w"> </span
            ><span class="default_value"><span class="pre">None</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.TokenizerInfo"
                title="xgrammar.tokenizer_info.TokenizerInfo"
                ><span class="pre">TokenizerInfo</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.from_huggingface"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Construct the tokenizer info from the huggingface tokenizer. This constructor supports
            various tokenizer backends, including the huggingface fast tokenizer and tiktoken
            tokenizer. Necessary information is automatically detected from the tokenizer.
          </p>
          <p>
            Note that some models (e.g. Phi-3 and Deepseek-V2) may pad the vocabulary to a multiple
            of 32. In this case, the model’s vocab_size is larger than the tokenizer’s vocabulary
            size. Please pass the model’s vocab_size (this should be defined in the model config) to
            the vocab_size parameter in the constructor, because this information is used to
            determine the size of the token mask.
          </p>
          <p>
            Some models can have more than one stop token ids, and auto detection may not find all
            of them. In this case, you can specify the stop token ids manually.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p>
                    <strong>tokenizer</strong> (<em>PreTrainedTokenizerBase</em>) – The huggingface
                    tokenizer.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>vocab_size</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em
                    ><em>, </em><em>default: None</em>) – The size of the vocabulary. If not
                    provided, the vocabulary size will be len(encoded_vocab).
                  </p>
                </li>
                <li>
                  <p>
                    <strong>stop_token_ids</strong> (<em>Optional</em><em>[</em><em>List</em
                    ><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>default: None</em>) –
                    The stop token ids. If not provided, the stop token ids will be auto detected
                    (but may not be correct).
                  </p>
                </li>
              </ul>
            </dd>
            <dt class="field-even">Returns<span class="colon">:</span></dt>
            <dd class="field-even">
              <p><strong>tokenizer_info</strong> – The tokenizer info.</p>
            </dd>
            <dt class="field-odd">Return type<span class="colon">:</span></dt>
            <dd class="field-odd">
              <p>
                <a
                  class="reference internal"
                  href="#xgrammar.TokenizerInfo"
                  title="xgrammar.TokenizerInfo"
                  >TokenizerInfo</a
                >
              </p>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py method">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.from_vocab_and_metadata">
          <em class="property"><span class="pre">static</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">from_vocab_and_metadata</span></span
          ><span class="sig-paren">(</span
          ><em class="sig-param"
            ><span class="n"><span class="pre">encoded_vocab</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><span class="n"
              ><span class="pre">List</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">Union</span><span class="p"><span class="pre">[</span></span
              ><span class="pre">bytes</span><span class="p"><span class="pre">,</span></span
              ><span class="w"> </span><span class="pre">str</span
              ><span class="p"><span class="pre">]</span></span
              ><span class="p"><span class="pre">]</span></span></span
            ></em
          >,
          <em class="sig-param"
            ><span class="n"><span class="pre">metadata</span></span
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="n"><span class="pre">str</span></span></em
          ><span class="sig-paren">)</span>
          <span class="sig-return"
            ><span class="sig-return-icon">→</span>
            <span class="sig-return-typehint"
              ><a
                class="reference internal"
                href="#xgrammar.TokenizerInfo"
                title="xgrammar.tokenizer_info.TokenizerInfo"
                ><span class="pre">TokenizerInfo</span></a
              ></span
            ></span
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.from_vocab_and_metadata"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Construct the tokenizer info from the vocabulary and the metadata string in json format.
          </p>
          <dl class="field-list simple">
            <dt class="field-odd">Parameters<span class="colon">:</span></dt>
            <dd class="field-odd">
              <ul class="simple">
                <li>
                  <p>
                    <strong>encoded_vocab</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em
                    ><em>bytes</em><em>, </em><em>str</em><em>]</em><em>]</em>) – The encoded
                    vocabulary of the tokenizer.
                  </p>
                </li>
                <li>
                  <p>
                    <strong>metadata</strong> (<em>str</em>) – The metadata string in json format.
                  </p>
                </li>
              </ul>
            </dd>
          </dl>
        </dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.prepend_space_in_tokenization">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"
            ><span class="pre">prepend_space_in_tokenization</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">bool</span></em
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.prepend_space_in_tokenization"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            Whether the tokenizer will prepend a space before the text in the tokenization process.
          </p>
        </dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.special_token_ids">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">special_token_ids</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">List</span
            ><span class="p"><span class="pre">[</span></span
            ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.special_token_ids"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd>
          <p>
            The special token ids. Special tokens include control tokens, reserved tokens, padded
            tokens, etc. Now it is automatically detected from the vocabulary.
          </p>
        </dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.stop_token_ids">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">stop_token_ids</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">List</span
            ><span class="p"><span class="pre">[</span></span
            ><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.stop_token_ids"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>The stop token ids.</p></dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.vocab_size">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">vocab_size</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span><span class="pre">int</span></em
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.vocab_size"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>The size of the vocabulary.</p></dd>
      </dl>

      <dl class="py property">
        <dt class="sig sig-object py" id="xgrammar.TokenizerInfo.vocab_type">
          <em class="property"><span class="pre">property</span><span class="w"> </span></em
          ><span class="sig-name descname"><span class="pre">vocab_type</span></span
          ><em class="property"
            ><span class="p"><span class="pre">:</span></span
            ><span class="w"> </span
            ><a
              class="reference internal"
              href="#xgrammar.VocabType"
              title="xgrammar.tokenizer_info.VocabType"
              ><span class="pre">VocabType</span></a
            ></em
          ><a
            class="headerlink"
            href="#xgrammar.TokenizerInfo.vocab_type"
            title="Permalink to this definition"
            >¶</a
          >
        </dt>
        <dd><p>The type of the vocabulary.</p></dd>
      </dl>
    </dd>
  </dl>

  <dl class="py class">
    <dt class="sig sig-object py" id="xgrammar.VocabType">
      <em class="property"><span class="pre">class</span><span class="w"> </span></em
      ><span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">VocabType</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">value</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"
          ><span class="pre">names=&lt;not</span> <span class="pre">given&gt;</span></span
        ></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">*values</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">module=None</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">qualname=None</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">type=None</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">start=1</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">boundary=None</span></span></em
      ><span class="sig-paren">)</span
      ><a class="headerlink" href="#xgrammar.VocabType" title="Permalink to this definition">¶</a>
    </dt>
    <dd>
      <p>
        The type of the vocabulary. Used in TokenizerInfo. XGrammar supports three types of
        vocabularies:
      </p>
      <dl>
        <dt>RAW</dt>
        <dd>
          <p>
            The vocabulary is in the raw format. The tokens in the vocabulary are kept in their
            original form without any processing. This kind of tokenizer includes the tiktoken
            tokenizer, e.g. microsoft/Phi-3-small-8k-instruct, Qwen/Qwen-7B-Chat, etc.
          </p>
        </dd>
        <dt>BYTE_FALLBACK</dt>
        <dd>
          <p>
            The vocabulary used in the byte fallback BPE tokenizer. The tokens are encoded through
            the byte-fallback conversion. E.g. “” -&gt; “&lt;0x1B&gt;”, ” apple” -&gt; “▁apple”.
            This kind of tokenizer includes meta-llama/Llama-2-7b-chat,
            microsoft/Phi-3.5-mini-instruct, etc.
          </p>
        </dd>
        <dt>BYTE_LEVEL</dt>
        <dd>
          <p>
            The vocabulary used in the byte level BPE tokenizer. The tokens are encoded through the
            byte-to-unicode conversion, as in
            <a
              class="reference external"
              href="https://github.com/huggingface/transformers/blob/87be06ca77166e6a6215eee5a990ab9f07238a18/src/transformers/models/gpt2/tokenization_gpt2.py#L38-L59"
              >https://github.com/huggingface/transformers/blob/87be06ca77166e6a6215eee5a990ab9f07238a18/src/transformers/models/gpt2/tokenization_gpt2.py#L38-L59</a
            >
          </p>
          <p>
            This kind of tokenizer includes meta-llama/Meta-Llama-3-8B-Instruct,
            meta-llama/Meta-Llama-3.1-8B-Instruct, etc.
          </p>
        </dd>
      </dl>
    </dd>
  </dl>

  <dl class="py function">
    <dt class="sig sig-object py" id="xgrammar.allocate_token_bitmask">
      <span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">allocate_token_bitmask</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">batch_size</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">int</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">vocab_size</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">int</span></span></em
      ><span class="sig-paren">)</span>
      <span class="sig-return"
        ><span class="sig-return-icon">→</span>
        <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span
      ><a
        class="headerlink"
        href="#xgrammar.allocate_token_bitmask"
        title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd>
      <p>
        Allocate the bitmask for the next token prediction. The bitmask is an int32 tensor on CPU
        with shape (batch_size, ceil(vocab_size / 32)). Users who have their own needs to manage
        CUDA memory can construct the tensor with get_bitmask_shape and bitmask_dtype themselves.
      </p>
      <p>
        The reason why we use int32 instead of uint32 is that old versions of PyTorch do not support
        uint32.
      </p>
      <dl class="field-list simple">
        <dt class="field-odd">Parameters<span class="colon">:</span></dt>
        <dd class="field-odd">
          <ul class="simple">
            <li>
              <p><strong>batch_size</strong> (<em>int</em>) – The batch size of the bitmask.</p>
            </li>
            <li>
              <p><strong>vocab_size</strong> (<em>int</em>) – The size of the vocabulary.</p>
            </li>
          </ul>
        </dd>
        <dt class="field-even">Returns<span class="colon">:</span></dt>
        <dd class="field-even">
          <p><strong>bitmask</strong> – The shape of the bitmask.</p>
        </dd>
        <dt class="field-odd">Return type<span class="colon">:</span></dt>
        <dd class="field-odd"><p>torch.Tensor</p></dd>
      </dl>
    </dd>
  </dl>

  <dl class="py function">
    <dt class="sig sig-object py" id="xgrammar.apply_token_bitmask_inplace">
      <span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">apply_token_bitmask_inplace</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">logits</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">bitmask</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em
      >,
      <em class="sig-param"
        ><span class="o"><span class="pre">*</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">indices</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span
        ><span class="n"
          ><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">List</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">int</span><span class="p"><span class="pre">]</span></span
          ><span class="p"><span class="pre">]</span></span></span
        ><span class="w"> </span><span class="o"><span class="pre">=</span></span
        ><span class="w"> </span
        ><span class="default_value"><span class="pre">None</span></span></em
      ><span class="sig-paren">)</span>
      <span class="sig-return"
        ><span class="sig-return-icon">→</span>
        <span class="sig-return-typehint"><span class="pre">None</span></span></span
      ><a
        class="headerlink"
        href="#xgrammar.apply_token_bitmask_inplace"
        title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd>
      <p>
        Apply the bitmask to the logits in-place. The bitmask is a 01 bitwise compressed tensor,
        where 0 means the token is masked and 1 means the token is not masked. It can be generated
        by allocate_token_bitmask and filled by fill_next_token_bitmask. After applying the bitmask,
        the masked logits will be set to -inf.
      </p>
      <p>
        The shape of logits and bitmask should be (batch_size, vocab_size) and (batch_size,
        bitmask_size) respectively. bitmask_size = ceil(vocab_size / 32). The operation is:
      </p>
      <div class="highlight-python notranslate">
        <div class="highlight">
          <pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">get_bitmask_value</span><span class="p">(</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logits</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>
</pre>
        </div>
      </div>
      <p>get_bitmask_value(bitmask, i, j) gets the j-th bit of the i-th row of the bitmask.</p>
      <p>
        Indices can be used to specify which logits in the batch to apply the bitmask to. It is
        especially useful when there are structured requests and unstructured requests mixed in the
        same batch by skipping masking the logits in the unstructured requests. When specified, the
        operation will be
      </p>
      <div class="highlight-python notranslate">
        <div class="highlight">
          <pre><span></span><span class="k">for</span> <span class="n">batch_id</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">get_bitmask_value</span><span class="p">(</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">batch_id</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logits</span><span class="p">[</span><span class="n">batch_id</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>
</pre>
        </div>
      </div>
      <p>
        The logits and bitmask should be on the same device. If both them are on CUDA, we launch a
        CUDA kernel to apply bitmask. If both them are on CPU, we use a CPU implementation. The CUDA
        kernel is optimized and should be preferred.
      </p>
      <p>
        In practice, the bitmask is allocated on CPU, and the logits is usually on GPU, so users
        should manually copy the bitmask to GPU before calling this function.
      </p>
      <dl class="field-list simple">
        <dt class="field-odd">Parameters<span class="colon">:</span></dt>
        <dd class="field-odd">
          <ul class="simple">
            <li>
              <p>
                <strong>logits</strong> (<em>torch.Tensor</em>) – The tensor to apply the bitmask
                to.
              </p>
            </li>
            <li>
              <p><strong>bitmask</strong> (<em>torch.Tensor</em>) – The bitmask to apply.</p>
            </li>
            <li>
              <p>
                <strong>indices</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em
                ><em>int</em><em>]</em><em>]</em><em>, </em><em>default: None</em>) – A list of
                indices to specify which logits in the batch to apply the bitmask to. If None, apply
                the bitmask to all logits in the batch.
              </p>
            </li>
          </ul>
        </dd>
      </dl>
    </dd>
  </dl>

  <dl class="py function">
    <dt class="sig sig-object py" id="xgrammar.get_bitmask_shape">
      <span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">get_bitmask_shape</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">batch_size</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">int</span></span></em
      >,
      <em class="sig-param"
        ><span class="n"><span class="pre">vocab_size</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">int</span></span></em
      ><span class="sig-paren">)</span>
      <span class="sig-return"
        ><span class="sig-return-icon">→</span>
        <span class="sig-return-typehint"
          ><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span
          ><span class="pre">int</span><span class="p"><span class="pre">,</span></span
          ><span class="w"> </span><span class="pre">int</span
          ><span class="p"><span class="pre">]</span></span></span
        ></span
      ><a class="headerlink" href="#xgrammar.get_bitmask_shape" title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd><p>Return the shape of the bitmask: (batch_size, ceil(vocab_size / 32))</p></dd>
  </dl>

  <dl class="py function">
    <dt class="sig sig-object py" id="xgrammar.reset_token_bitmask">
      <span class="sig-prename descclassname"><span class="pre">xgrammar.</span></span
      ><span class="sig-name descname"><span class="pre">reset_token_bitmask</span></span
      ><span class="sig-paren">(</span
      ><em class="sig-param"
        ><span class="n"><span class="pre">bitmask</span></span
        ><span class="p"><span class="pre">:</span></span
        ><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em
      ><span class="sig-paren">)</span>
      <span class="sig-return"
        ><span class="sig-return-icon">→</span>
        <span class="sig-return-typehint"><span class="pre">None</span></span></span
      ><a
        class="headerlink"
        href="#xgrammar.reset_token_bitmask"
        title="Permalink to this definition"
        >¶</a
      >
    </dt>
    <dd><p>Reset the bitmask to the full mask.</p></dd>
  </dl>
</section>
